---
title: フロントエンドプロジェクトガイド (Next.js & Supabase)
created_at: 2025-06-21
updated_at: 2025-06-21
---

このドキュメントは、Next.js と Supabase を使用したフロントエンドプロジェクトにおける特有の注意点とベストプラクティスを提供します。

## Next.js & Supabase 開発における重要事項

### 1. ルーティング: ルートグループはURLセグメントではない

- **問題**: `/(admin)/page.tsx` のようなルートグループを、URLパス (`/admin`) として扱ってしまう。
- **解説**: Next.jsのルートグループ `(folder)` は、あくまでファイル構成を整理するためのものであり、URLのパスには影響しません。例えば、`app/(main)/page.tsx` は `app/page.tsx` と同じく `/` にマッピングされます。もし `app/(admin)/page.tsx` と `app/page.tsx` が両方存在すると、同じパスに2つのページが競合するためエラーが発生します。
- **指示する際のポイント**: ルーティングに影響を与えずにコンポーネントを整理したい場合は「ルートグループを使ってください」と、明確にURLパスを分けたい場合は「`/admin` のような新しいルートを作成してください」と指示してください。

### 2. データフェッチ: `useEffect` ではなくサーバーコンポーネントで & `useEffect` 最小化ガイド

- **問題**: クライアントコンポーネントで `useEffect` を使ってデータをフェッチしてしまう。

#### 2.1. 原則
- **App Router ではサーバーコンポーネント (SC)** でデータを取得し、クライアントには最小限の JS だけを配信する。  
- **`useEffect` は「外部副作用」専用の最後の手段**。Meta 社調査では **46 %** が不要だったと判明。まずは使わずに済む方法を検討する。

#### 2.2. 実装フロー
1. **DAL** (Data-Access Layer) を `src/lib/data-access.ts` などに集約。  
2. SC 内で `await getData()` して返す。  
3. 必要なら `<Suspense fallback={<Skeleton/>}>` で包み、ストリーミング。  

#### 2.3. `useEffect` 回避パターン
| やりたいこと | 推奨代替策 |
|--------------|-----------|
| SSR/SSG 時点で決まるデータ取得 | **SC から直接フェッチ** |
| クライアント状態依存の再フェッチ | **`use()` + Suspense** (React 18+) |
| 単純な UI イベント応答 | イベントハンドラ内で同期実行 |
| 高価な計算結果のキャッシュ | `useMemo` |

#### 2.4. `useEffect` を書いてよい具体例
1. **DOM 直接操作**（フォーカス・スクロール制御）  
2. **外部ライブラリの初期化/破棄**（Chart.js, Mapbox など）  
3. **WebSocket / subscription** の開始とクリーンアップ  
4. **タイマー系**（`setTimeout`, `setInterval`）のライフサイクル管理  
5. **(React 18 未満)** クライアント側 API 呼び出し副作用  

#### 2.5. 典型的アンチパターンと是正策
| アンチパターン | 問題 | 是正策 |
|----------------|------|--------|
| 依存配列の抜け／過剰 | 無限ループ・不要レンダリング | ESLint `exhaustive-deps` を守り最小化 |
| データ変換を effect 内で実行 | パフォーマンス低下 | 関数本体または `useMemo` |
| 1 つの effect に複数責務 | 読みにくくテスト困難 | **単責任**に分割し、必要ならカスタムフック化 |

#### 2.6. 実装チェックリスト
- [ ] SC でデータ取得できないか？  
- [ ] それでも `useEffect` が必要な「外部副作用」か？  
- [ ] 依存配列は最小？  
- [ ] 必要なクリーンアップ関数を返しているか？  
- [ ] 「なぜ `useEffect` が必要か」をコメントしたか？  

### 3. UI/UX: `Suspense`によるストリーミングとスケルトン表示

- **問題**: データ取得が完了するまでページ全体がブロックされてしまう。
- **ベストプラクティス**: 重いデータ取得処理を行うコンポーネントを `React.Suspense` でラップし、`fallback` にスケルトンコンポーネントを指定します。これにより、他のUIを先に表示しつつ、データの準備ができた部分から段階的に表示（ストリーミング）できます。
- **指示する際のポイント**: 「データ取得中はスケルトンUIを表示し、`Suspense` を使ってストリーミングしてください」と指示してください。

### 4. データ更新: `Server Actions` を積極的に活用する

- **問題**: フォーム送信などのデータ更新処理を、クライアントサイドのイベントハンドラとAPIルートで実装してしまう。
- **ベストプラクティス**: `Server Actions` を使うと、クライアントからサーバー上の関数を直接呼び出せます。これにより、APIエンドポイントを別途作成する必要がなくなり、コードがシンプルになります。フォームやボタンのイベントに直接バインドするのが理想的です。
- **指示する際のポイント**: 「このフォームの処理は Server Actions で実装してください」と明確に指示することが重要です。

### 5. 動的データ: `searchParams` と動的ルートの非同期取得

- **問題**: ページのプロップスで `searchParams` や動的ルートの `params` を同期的に受け取ろうとしてエラーになる。
- **解説**: App Routerでは、これらのプロップスは非同期でページコンポーネントに渡されます。ページコンポーネントは `async` 関数として定義する必要があります。
- **実装例**:
  ```typescript
  // app/blog/[id]/page.tsx
  export default async function BlogPostPage({ params, searchParams }: {
    params: { id: string };
    searchParams: { [key: string]: string | string[] | undefined };
  }) {
    // params.id や searchParams を使った処理
    const post = await getPost(params.id);
    return <div>...</div>;
  }
  ```
- **指示する際のポイント**: 「このページは `useSearchParams` ではなく、非同期プロップス `searchParams` を使ってください」と指示すると確実です。

### 6. Supabase: サーバーサイドとクライアントサイドのクライアントを使い分ける

- **問題**: サーバーコンポーネントやServer Actions内で、クライアント用のSupabaseクライアントを使ってしまう。
- **解説**: 実行環境に応じて適切なクライアントを生成する必要があります。
  - **クライアントサイド (Client Components)**: `createClient()` (`@supabase/supabase-js`) を使用します。
  - **サーバーサイド (Server Components, Route Handlers, Server Actions)**: `createServerClient()` (`@supabase/ssr`) を使用します。これにより、ユーザーのセッション情報（Cookie）を安全に扱うことができます。
- **指示する際のポイント**: 「ここはサーバーコンポーネントなので、Supabaseの `createServerClient` を使ってください」と指示すると、適切なクライアントが選択されます。